<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_38) on Sun Aug 25 09:59:19 UTC 2013 -->
<TITLE>
SmartArchitecture
</TITLE>

<META NAME="date" CONTENT="2013-08-25">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SmartArchitecture";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/smartgwt/client/docs/Skins.html" title="interface in com.smartgwt.client.docs"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/smartgwt/client/docs/Sorting.html" title="interface in com.smartgwt.client.docs"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/smartgwt/client/docs/SmartArchitecture.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SmartArchitecture.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;METHOD</FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;METHOD</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.smartgwt.client.docs</FONT>
<BR>
Interface SmartArchitecture</H2>
<HR>
<DL>
<DT><PRE>public interface <B>SmartArchitecture</B></DL>
</PRE>

<P>
<h3>Smart GWT Architecture</h3>
 Smart GWT can add interactivity and performance benefits to any web application with a
  variety of integration approaches.  This topic discusses the optimal architecture for a
  Smart GWT application, which can be adopted in whole or in part.
  <p>
  In a typical HTML-based web application, every time a new view is shown to a user, a round
  trip to the server is required to retrieve new presentation information, such as a search
  screen.  However in an ISC-based application, showing a new view can be accomplished by
  simply hiding some components and showing others.
  <p>
  Because ISC components are expressed in a concise declarative form, and because ISC
  components have essentially no runtime performance impact until used, dozens of application
  views can be downloaded to the browser using the same bandwidth that would have been
  required to render just the initial view in plain HTML.  
  <p> 
  This architectural pattern of "preloading views" has tremendous benefits.  View transitions
  which do not require new data from the server can be performed near-instantaneously and
  without server involvement, boosting both interactivity and scalability.
  <p>
  Showing a dialog containing a "wizard" is a straightforward example of showing a "preloaded
  view".  For example:
  <pre>
     function showNewUserWizard() {
         Window.create({
             items:[
                 DynamicForm.create({ ... })
             ]
         });
     }
     Button.create({
         title:"New User..",
         click:"showNewUserWizard()"
     });
  </pre>
  In this example, none of the components involved in a potentially multi-pane wizard are 
  created until they are needed.  Showing the wizard has near-instantaneous response and
  causes no server load.
  <p>
  However, let's say that the first pane of the wizard is going to incorporate some dynamic
  user-specific data, such as the current user's name.  To load the username, we'll use an RPC
  operation targetting a .jsp called "getUserName.jsp" and show the wizard when it completes
 (see <A HREF="../../../../com/smartgwt/client/rpc/RPCManager.html" title="class in com.smartgwt.client.rpc"><CODE>RPCManager</CODE></A> for information on RPCs and how to construct a
 .jsp that can
  send an RPC response).
  <pre>
     function showNewUserWizard() {
         RPCManager.sendRequest({
             actionURL:"getUserName.jsp",
             callback:"doShow(rpcResponse)"
         });
     }
     function doShow(rpcResponse) {
         Window.create({
             items:[
                 Canvas.create({contents:"Hello, " + rpcResponse.userName}),
                 DynamicForm.create({ ... })
             ]
         });
     }
     Button.create({
         title:"New User..",
         click:"showNewUserWizard()"
     });
  </pre>
  In this example, we've simply incorporated a user name into the first pane of a wizard.
  However, this pattern allows us to arbitrarily change user interactions based on data from
  the server.  For example, the RPCResponse might have contained a flag indicating that the
  wizard should skip the first two steps, or an arbitrary warning message for the user, or
  even JavaScript code to be evaluated on the client.
  <P>
  This architecture has several key advantages:
  <dl>
 
  <dt><b>Performance: Cacheable UI</b></dt>
  <dd>
  A dynamic, data-driven UI can be expressed completely in <i>cacheable</i> JavaScript.
  This is in contrast to any architecture based on server-side HTML generation, where static
  parts of the presentation are mixed in with dynamic data, preventing cacheability so that
  bandwidth and server time are wasted repeatedly delivering the same static presentation
  data.
  <br>
  Even generated JavaScript is cacheable.  For example, a Smart GWT View expressed in XML
  and contained within a JSP is still a separately cacheable resource when loaded via a
  &lt;SCRIPT SRC&gt; tag and advertised as a cacheable resource via HTTP headers, because it
  is ultimately delivered to the browser as simple JavaScript.  Hence standard 
 <A HREF="../../../../com/smartgwt/client/docs/I18n.html" title="interface in com.smartgwt.client.docs"><CODE>internationalization</CODE></A> techniques such as using JSTL tags
 in a JSP remain
  applicable.
  <br>
  The Smart GWT Architecture even allows you to capture all the gradations of cacheability
  from completely static (changes once per application rollout) to completely dynamic
  (timestamp).  In the example above, the user name wouldn't actually change for the lifetime
  of the page, so could be loaded once only.
  <br>&nbsp;</dd>
 
  <dt><b>Performance: Minimal Server State</b></dt>
  <dd>
  Any architecture that relies on component descriptions being generated by the server
  must track a great deal of state, which, in the Smart GWT Architecture, is either
  completely eliminated or greatly reduced.
  <br>&nbsp;</dd>
 
  <dt><b>True Presentation / Business Logic separation</b></dt>
  <dd>
  The RPCResponse object represents the client's exact, minimal needs for server data.
  This is much easier to understand and to audit than a slew of .jsp files which access and
  update miscellaneous state.  It is also far easier to spot reusable patterns of data access,
  which in server-side HTML generation systems often end up as duplicated code.
  <br>&nbsp;</dd>
 
  <dt><b>Parallel Development and Testability</b></dt>
  <dd>
  Using the Smart GWT architecture allows you to build a complete, working application
  that can run without a server, based on sample data.  In the example above, it would be 
  straightforward to create a testing mode that returned a faked RPC response consisting of
  simply <code>{ userName : "Bob" }</code>.
  <br>
  This allows better parallel development by enabling the client side of the system to be
  tested in isolation, and creates clearer communication between client and server-side
  developers since creation of test data tends to develop into data requirements
  specifications.
  <br>
  For more info on creating applications that support client-only testing, see
  <A HREF="../../../../com/smartgwt/client/docs/ClientOnlyDataSources.html" title="interface in com.smartgwt.client.docs"><CODE>Client Only DataSources</CODE></A>.
  <br>&nbsp;</dd>
  </dl>
  <br>
  <h3>Refinements</h3>
  <br>
  <b>Creating vs Showing a View</b>
  <br>
  Many views will be shown to the user repeatedly, for example, the user may repeatedly switch
  back and forth between two panes of a TabSet.  In that usage it makes sense to make a
  distinction between <i>creating</i> a view and <i>showing</i> an existing view.  When
  showing an existing view, the same components and/or data may be able to be reused.
  <br>
  In the following variant on the original example, we only create the Window object and
  do the RPC to retrieve the user name the first time <code>showNewUserWizard()</code> is
  called.  Subsequently we reuse the existing window, and we assume the user name has not
  changed, so we need not do the RPC again. (<i>Note: "New User" button omitted for brevity
  from here on</i>)
  <pre>
     function showNewUserWizard() {
         if (!window.myWindow) {
             Window.create({
                 ID:"myWindow",
                 autoDraw:false,
                 items:[
                     Canvas.create({ ID: "welcomeCanvas" }),
                     DynamicForm.create({ ... })
                 ]
             });
             RPCManager.sendRequest({
                 actionURL:"getUserName.jsp",
                 callback:"doShow(rpcResponse)"
             });
         } else {
             myWindow.show();
         }
     }
     function doShow(rpcResponse) {
         welcomeCanvas.setContents("Hello, " + rpcResponse.userName);
         myWindow.show();
     }
  </pre>
  
  <b>Batching Operations</b>
  <br>
  A view may incorporate multiple components, each of which requires data.  In the following
  example, a DataBound ListGrid has been incorporated into the wizard, and we'd like to fetch
  the user's name and the beginning dataset for the grid in the same batch.  We use 
  <A HREF="../../../../com/smartgwt/client/rpc/RPCManager.html#startQueue()"><CODE>RPCManager.startQueue</CODE></A> to do so.
  <pre>
     function showNewUserWizard() {
         if (!window.myWindow) {
             Window.create({
                 ID:"myWindow",
                 autoDraw:false,
                 items:[
                     Canvas.create({ ID: "welcomeCanvas" }),
                     <b>ListGrid.create({ 
                         ID: "myGrid",
                         dataSource:"myDataSource"
                     }),</b>
                     DynamicForm.create({ ... })
                 ]
             });
             <b>RPCManager.startQueue();
             myGrid.fetchData();</b>
             RPCManager.sendRequest({
                 actionURL:"getUserName.jsp",
                 callback:"doShow(rpcResponse)"
             });
             <b>RPCManager.sendQueue();</b>
         } else {
             myWindow.show();
         }
     }
     function doShow(rpcResponse) {
         welcomeCanvas.setContents("Hello, " + rpcResponse.userName);
         myWindow.show();
     }
  </pre>
 
  <b>Segmenting very large Applications</b>
  <P>
  If an application has many hundreds of views, but only a handful of views are used by a
  given user in a typical session, for the fastest loading performance you should consider
  loading only the most commonly used views initially then loading further views on demand.
  <P>
  You can use  FileLoader.loadJSFiles to load a set of JavaScript files
  compromising an application module that defines a set of related views.  The loaded
  JavaScript files may define new component classes and new DataSources in addition to
  defining new views and their associated logic.
<P>

<P>
<HR>

<P>

<P>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/smartgwt/client/docs/Skins.html" title="interface in com.smartgwt.client.docs"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/smartgwt/client/docs/Sorting.html" title="interface in com.smartgwt.client.docs"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?com/smartgwt/client/docs/SmartArchitecture.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SmartArchitecture.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;METHOD</FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;METHOD</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
